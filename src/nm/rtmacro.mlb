//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//              ������� ����������� ����������� ���������������             //
//                                                                          //
//              ���������� ������� ����������                               //
//                                                                          //
//                          ������ RTMACRO                                  //
//                                                                          //
//   ������� ��� ���������� ������������� ����, ��������������              //
//   ������ �� ����������� ������ ������                                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

// ������: ��������, �������� �.�.
// ������: 02 ( 27.11.97 )
// ������: ������������
// �����������: ���� ������������� � ���������� ��������, ������� �������������
// �� ���� ������������ ������, ����������� ���������������.
// ������ 2: �������� ���������� � ������ ���������� �������. ��� ������ ������
// ������� � ������� CALL_BUILTIN_xxx. ���������� ������������ �����.

// ���������: ������� gr7 ������ ������������ � �������� ��������� ������
// ��������.

    //-------------------------------------------------
    // ������� ��������� � ������� �� ���������� libasm
    //-------------------------------------------------

// ������� �� ���������� libasm ����� ���� ����������� ���������
// � �������. ������ ��������� ����������� ��� ������� � ��������� 
// ������ ����������.
// ������� CALL_BUILTIN_xxxx ������ ��������� � ������ ��� �������
// � ����������� �� ����� ����������.
// ������ ������� ��������������� ��� ��������� ��������.
// CALL_BUILTIN_2x1 - ������� ��������� ��� ���������, ���������� ���� 
// CALL_BUILTIN_4x2 - ������� ��������� ������ ���������, ���������� ���
// CALL_BUILTIN_2x2 - ������� ��������� ��� ���������, ���������� ��� 
// CALL_BUILTIN_1x2 - ������� ��������� ���� ��������, ���������� ��� 

//==============================================================
// ������ �������� ������� � ����� �����������
// ������������ �������� ���������� � ���� �������
// 
// CALL_BUILTIN_2x1( 
//          Func,   - ��� ���������� �������
//          Arg1,   - ������� ������� ���������
//          Arg2,   - ������� ������� ���������
//          Res     - ������� ����������
//     )
//
//==============================================================
macro CALL_BUILTIN_2x1( Func, Arg1, Arg2, Res )

        // ������������� ������� ���������� � ������� ��� 2 ����������
        // ��������� ������� ��������� ���� ������������ PC,PSW
    delayed call Func;
    push Arg1;
    push Arg2;
        // end of delayed commands of call

    Res = gr7;

end CALL_BUILTIN_2x1;

//==============================================================
// ������ �������� ������� � �������� �����������
// ������������ �������� ���������� � ��� ��������
// 
// CALL_BUILTIN_4x2( 
//          Func,   - ��� ���������� �������
//          Arg1,   - ������� ������� ���������
//          Arg2,   - ������� ������� ���������
//          Arg3,   - ������� �������� ���������
//          Arg4,   - ������� ���������� ���������
//          Res1,   - ������ ������� ����������
//          Res2    - ������ ������� ����������
//     )
//
//==============================================================
macro CALL_BUILTIN_4x2( Func, Arg1, Arg2, Arg3, Arg4, Res1, Res2 )

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = Arg1;
    [ ar5++ ] = Arg2;
    [ ar5++ ] = Arg3;
    [ ar5 ] = Arg4;

    call Func;

    ar5 = sp;
    Res1 = [ --ar5 ];
    Res2 = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;

end CALL_BUILTIN_4x2;

//==============================================================
// ������ �������� ������� � ����� �����������
// ������������ �������� ���������� � ��� ��������
// 
// CALL_BUILTIN_2x2( 
//          Func,   - ��� ���������� �������
//          Arg1,   - ������� ������� ���������
//          Arg2,   - ������� ������� ���������
//          Res1,   - ������ ������� ����������
//          Res2    - ������ ������� ����������
//     )
//
//==============================================================
macro CALL_BUILTIN_2x2( Func, Arg1, Arg2, Res1, Res2 )

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = Arg1;
    [ ar5 ] = Arg2;

    call Func;

    ar5 = sp;
    Res1 = [ --ar5 ];
    Res2 = [ --ar5 ];
    sp -= 2;

end CALL_BUILTIN_2x2;

//==============================================================
// ������ �������� ������� � ����� ����������
// ������������ �������� ���������� � ��� ��������
// 
// CALL_BUILTIN_1x2( 
//          Func,   - ��� ���������� �������
//          Arg1,   - ������� ������� ���������
//          Res1,   - ������ ������� ����������
//          Res2    - ������ ������� ����������
//     )
//
//==============================================================
macro CALL_BUILTIN_1x2( Func, Arg, Res1, Res2 )

        // ������������� ������� ������:
        // �������� ���������� � gr7
        // ������������ �������� �� ������� �����.
    delayed call Func with gr7 = Arg;
    nul 32;
    // call Func;

    if false delayed skip 2;
    Res1 = [ --ar7 ];
    Res2 = [ --ar7 ];
    // if never delayed skip 2;

end CALL_BUILTIN_1x2;


    //-------------------------------------------------
    // ������� ��� ���������������� �������� � 
    // ��������� ������� - 32 ����.
    // ������� ��� ������ � �������� ������� 64 ����
    //-------------------------------------------------



//======== ������ MULT32 =========
// ��������� 32-������ �����, �������� ��� �����������,
// � 32-������ �����������. (����� ������� � ������� �������).
// �� �����:    Arg1 - ������� � ������ ����������
//              Arg2 - ������� �� ������ ����������
// �� ������:   Res - ������� 32 ���� ����������
// ��������:    gr7
// ���������: Arg1 � Arg2 ����� ���������.
macro MULT32 ( Res, Arg1, Arg2 )

    extern Mul32 : label;
    
    CALL_BUILTIN_2x1( Mul32, Arg1, Arg2, Res );
    
end MULT32;
    
//======== ������ MULT32Speed =========
// ��������� 32-������ �����, �������� ��� �����������,
// � 32-������ �����������.
// ������ ������� ������� ������ �� 30%, ���� � 3 ���� ������ �� ����.
// �� �����:    Arg1 - ������� � ������ ����������
//              Arg2 - ������� �� ������ ����������
// �� ������:   Res - ������� 32 ���� ����������
// ��������:    gr7
// ���������: Arg1 � Arg2 �� ����� ���������.

macro MULT32Speed ( Res, Arg1, Arg2 )

    with gr7 = Arg2;
    with Arg2 = Arg1 *: gr7;
.repeat 15;
    with Arg2 = Arg1 * gr7;
.endrepeat;
    with Res = gr7;

end MULT32Speed;


//======= ������ IDIV32 =========
// ������� 32-��������� ����� �� ������
// �� �����:    Arg1 - ������� � �������,
//              Arg2 - ������� � ���������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �������.
// ��������:    gr7,ar5.
macro IDIV32 ( Res, Arg1, Arg2 )
extern IDiv32 :label;

    CALL_BUILTIN_2x1( IDiv32, Arg1, Arg2, Res );

end IDIV32;


//======= ������ UDIV32 =========
// ������� 32-��������� ����� ��� �����.
// �� �����:    Arg1 - ������� � �������,
//              Arg2 - ������� � ���������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �������.
// ��������:    gr7,ar5.
macro UDIV32 ( Res, Arg1, Arg2 )
extern UDiv32 :label;

    CALL_BUILTIN_2x1( UDiv32, Arg1, Arg2, Res );

end UDIV32;


//======= ������ IMOD32 =========
// ���������� ������� �� ������� 32-��������� ����� �� ������
// �� �����:    Arg1 - ������� � �������,
//              Arg2 - ������� � ���������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � ��������.
// ��������:    gr7,ar5.
macro IMOD32 ( Res, Arg1, Arg2 )
extern IMod32 :label;

    CALL_BUILTIN_2x1( IMod32, Arg1, Arg2, Res );

end IMOD32;


//======= ������ UMOD32 =========
// ���������� ������� �� ������� 32-��������� ����� �� ������
// �� �����:    Arg1 - ������� � �������,
//              Arg2 - ������� � ���������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � ��������.
// ��������:    gr7,ar5.
macro UMOD32 ( Res, Arg1, Arg2 )
extern UMod32 :label;

    CALL_BUILTIN_2x1( UMod32, Arg1, Arg2, Res );

end UMOD32;


//======= ������ LSHIFT32 ========
// ���������� ����� ����� 32-������� �����.
// �������� ������ ��������� � ��������.
// �� �����:    Arg - ������� �� ���������� ���������,
//              Val - ������� � ��������� ������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �����������.
// ��������:    gr7,ar5.
macro LSHIFT32 ( Res, Arg, Val )
extern LShift32 :label;

    CALL_BUILTIN_2x1( LShift32, Arg, Val, Res );

end LSHIFT32;


//======= ������ RSHIFT32 ========
// ���������� ����� ������ 32-������� �����.
// �������� ������ ��������� � ��������.
// �� �����:    Arg - ������� �� ���������� ���������,
//              Val - ������� � ��������� ������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �����������.
// ��������:    gr7,ar5.
macro RSHIFT32 ( Res, Arg, Val )
extern RShift32 :label;

    CALL_BUILTIN_2x1( RShift32, Arg, Val, Res );

end RSHIFT32;


//======= ������ ARSHIFT32 ========
// �������������� ����� ������ 32-������� �����.
// �������� ������ ��������� � ��������.
// �� �����:    Arg - ������� �� ���������� ���������,
//              Val - ������� � ��������� ������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �����������.
// ��������:    gr7,ar5.
macro ARSHIFT32 ( Res, Arg, Val )
extern ARShift32 :label;

    CALL_BUILTIN_2x1( ARShift32, Arg, Val, Res );

end ARSHIFT32;


//======= ������ UTRUNC8 ========
// �������� 32-���������� �������� �� 8 ������� ��� ��� ��������������� �����.
// �� �����:    Src - ������� � ���������.
// �� ������:   Dst - ������� � �����������.
macro UTRUNC8 ( Dst, Src )
    Dst = Src << 24;
    Dst >>= 24;
end UTRUNC8;


//======= ������ ITRUNC8 ========
// �������� 32-���������� �������� �� 8 ������� ��� c ���������������� �����
// 8-�� ����.
// �� �����:    Src - ������� � ���������.
// �� ������:   Dst - ������� � �����������.
macro ITRUNC8 ( Dst, Src )
    Dst = Src << 24;
    Dst A>>= 24;
end ITRUNC8;


//======= ������ UTRUNC16 ========
// �������� 32-���������� �������� �� 16 ������� ��� ��� ��������������� �����.
// �� �����:    Src - ������� � ���������.
// �� ������:   Dst - ������� � �����������.
macro UTRUNC16 ( Dst, Src )
    Dst = Src << 16;
    Dst >>= 16;
end UTRUNC16;


//======= ������ ITRUNC16 ========
// �������� 32-���������� �������� �� 16 ������� ��� c ���������������� �����
// 16-�� ����.
// �� �����:    Src - ������� � ���������.
// �� ������:   Dst - ������� � �����������.
macro ITRUNC16 ( Dst, Src )
    Dst = Src << 16;
    Dst A>>= 16;
end ITRUNC16;


//======= ������ LOAD64C ========
// �������� ����������� ���� 64-������ ���������.
// �� �����:    Val - ��������-���������.
// �� ������:   ResLo - ������� � �������� 32 ������,
//              ResHi - ������� �� �������� 32 ������.
macro LOAD64C ( ResLo, ResHi, Val )
    ResLo = loword( Val );
    ResHi = hiword( Val );
end LOAD64C;


macro ADD64 ( ResLo, ResHi, A1Lo, A1Hi, A2Lo, A2Hi )
            gr7 = A1Lo + A2Lo;
            ResLo = gr7
                with ResHi = A1Hi + A2Hi + carry;
end ADD64;


macro SUB64 ( ResLo, ResHi, A1Lo, A1Hi, A2Lo, A2Hi )
            gr7 = A1Lo - A2Lo;
            ResLo = gr7
                with ResHi = A1Hi - A2Hi - 1 + carry;
end SUB64;


//======= ������ NEG64 ========
// ��������� ����� 64-���������� �����.
// �� �����:    ArgLo - ������� 32 ���� ��������,
//              ArgHi - ������� 32 ���� ��������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
// ��������: gr7, ArgLo.
macro NEG64 ( ResLo, ResHi, ArgLo, ArgHi )
    ResHi = false;
    ArgLo = -ArgLo;
    ResLo = ArgLo
        with ResHi = ResHi - ArgHi - 1 + carry;
end NEG64;


//======= ������ MULT64 =========
// ��������� 64-������ �����, �������� ���� �����������.
// �� �����:    LeftLo - ������� 32 ���� 1-�� ��������,
//              LeftHi - ������� 32 ���� 1-�� ��������,
//              RightLo - ������� 32 ���� 2-�� ��������,
//              RightHi - ������� 32 ���� 2-�� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
macro MULT64 ( ResLo, ResHi, LeftLo, LeftHi, RightLo, RightHi )

    extern Mul64 :label;

    CALL_BUILTIN_4x2(Mul64, LeftLo, LeftHi, RightLo, RightHi, ResHi, ResLo );
    
end MULT64;

//======= ������ MULT64Vect =========
// ��������� 64-������ �����, �������� ���� �����������.
// ������ ������� ������������ ��������� ���������.
// �� �����:    LeftLo - ������� 32 ���� 1-�� ��������,
//              LeftHi - ������� 32 ���� 1-�� ��������,
//              RightLo - ������� 32 ���� 2-�� ��������,
//              RightHi - ������� 32 ���� 2-�� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
macro MULT64Vect ( ResLo, ResHi, LeftLo, LeftHi, RightLo, RightHi )

    nb1 = 0;        // ������� ����
    sb = 0;
    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LeftLo;
    [ ar5++ ] = LeftHi;
    [ ar5++ ] = RightLo;
    [ ar5++ ] = RightHi;
    rep 1 wfifo = [ --ar5 ], ftw, wtw;
    rep 1 data = [ --ar5 ] with vsum , data, 0;
    rep 1 [ar5] = afifo;
    ResLo = [ ar5++ ];
    ResHi = [ ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).
    sp -= 4;
    
end MULT64Vect;


//======= ������ IDIV64 ========
// ������� 64-��������� ����� �� ������.
// �� �����:    LeftLo - ������� 32 ���� 1-�� ��������,
//              LeftHi - ������� 32 ���� 1-�� ��������,
//              RightLo - ������� 32 ���� 2-�� ��������,
//              RightHi - ������� 32 ���� 2-�� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
macro IDIV64 ( ResLo, ResHi, LeftLo, LeftHi, RightLo, RightHi )
extern IDiv64 :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LeftLo;
    [ ar5++ ] = LeftHi;
    [ ar5++ ] = RightLo;
    [ ar5 ]   = RightHi;
    call IDiv64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).
    sp -= 4;
end IDIV64;


//======= ������ UDIV64 ========
// ������� 64-��������� ����� ��� �����.
// �� �����:    LeftLo - ������� 32 ���� 1-�� ��������,
//              LeftHi - ������� 32 ���� 1-�� ��������,
//              RightLo - ������� 32 ���� 2-�� ��������,
//              RightHi - ������� 32 ���� 2-�� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
macro UDIV64 ( ResLo, ResHi, LeftLo, LeftHi, RightLo, RightHi )
extern UDiv64 :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LeftLo;
    [ ar5++ ] = LeftHi;
    [ ar5++ ] = RightLo;
    [ ar5 ]   = RightHi;
    call UDiv64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end UDIV64;


//======= ������ IMOD64 ========
// ���������� ������� �� ������� 64-��������� ����� �� ������.
// �� �����:    LeftLo - ������� 32 ���� 1-�� ��������,
//              LeftHi - ������� 32 ���� 1-�� ��������,
//              RightLo - ������� 32 ���� 2-�� ��������,
//              RightHi - ������� 32 ���� 2-�� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
macro IMOD64 ( ResLo, ResHi, LeftLo, LeftHi, RightLo, RightHi )
extern IMod64 :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LeftLo;
    [ ar5++ ] = LeftHi;
    [ ar5++ ] = RightLo;
    [ ar5 ]   = RightHi;
    call IMod64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end IMOD64;


//======= ������ UMOD64 ========
// ���������� ������� �� ������� 64-��������� ����� ��� �����.
// �� �����:    LeftLo - ������� 32 ���� 1-�� ��������,
//              LeftHi - ������� 32 ���� 1-�� ��������,
//              RightLo - ������� 32 ���� 2-�� ��������,
//              RightHi - ������� 32 ���� 2-�� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
macro UMOD64 ( ResLo, ResHi, LeftLo, LeftHi, RightLo, RightHi )
extern UMod64 :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LeftLo;
    [ ar5++ ] = LeftHi;
    [ ar5++ ] = RightLo;
    [ ar5 ]   = RightHi;
    call UMod64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end UMOD64;


//======= ������ LSHIFT64 ========
// ���������� ����� ����� 64-���������� �����.
// �������� ������ ��������� � ��������.
// �� �����:    ArgLo - ������� 32 ���� ��������,
//              ArgHi - ������� 32 ���� ��������,
//              Sh - �������� ������,
//              ���� �������� �� ������� ������.
// ��������: gr7,ar5.
macro LSHIFT64 ( ResLo, ResHi, ArgLo, ArgHi, Sh )
extern LShift64 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo
        with gr7 = Sh;
    [ ar5++ ] = ArgHi;
    call LShift64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end LSHIFT64;


//======= ������ RSHIFT64 ========
// ���������� ����� ������ 64-���������� �����.
// �������� ������ ��������� � ��������.
// �� �����:    ArgLo - ������� 32 ���� ��������,
//              ArgHi - ������� 32 ���� ��������,
//              Sh - �������� ������,
//              ���� �������� �� ������� ������.
// ��������: gr7,ar5.
macro RSHIFT64 ( ResLo, ResHi, ArgLo, ArgHi, Sh )
extern RShift64 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo
        with gr7 = Sh;
    [ ar5++ ] = ArgHi;
    call RShift64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end RSHIFT64;


//======= ������ ARSHIFT64 ========
// �������������� ����� ������ 64-���������� �����.
// �������� ������ ��������� � ��������.
// �� �����:    ArgLo - ������� 32 ���� ��������,
//              ArgHi - ������� 32 ���� ��������,
//              Sh - �������� ������,
//              ���� �������� �� ������� ������.
// ��������: gr7,ar5.
macro ARSHIFT64 ( ResLo, ResHi, ArgLo, ArgHi, Sh )
extern ARShift64 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo
        with gr7 = Sh;
    [ ar5++ ] = ArgHi;
    call ARShift64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end ARSHIFT64;


//======= ������ I32TO64 =========
// �������������� 32-������� ������ �� ������ � 64-������.
// �� �����:    Val - ������� � ���������
// �� ������:   ResLo - ������� � �������� 32 ������ ����������
//              ResHi - ������� �� �������� 32 ������ ����������
macro I32TO64 ( ResLo, ResHi, Val )
    ResLo = Val
        with ResHi = Val A>> 31;
end I32TO64;


//======= ������ U32TO64 =========
// �������������� 32-������� ������ ��� ����� � 64-������.
// �� �����:    Val - ������� � ���������
// �� ������:   ResLo - ������� � �������� 32 ������ ����������
//              ResHi - ������� �� �������� 32 ������ ����������
macro U32TO64 ( ResLo, ResHi, Val )
    ResLo = Val
        with ResHi = false;
end U32TO64;


//======= ������ STASG ========
// ��������� ���, ���������� (���������) ������ ������ (���������).
// �� �����:    Dst - �������� ������� � ������� ���������� (�� ar5),
//              Src - �������� ������� � ������� ��������� (�� ar5),
//              Size - ����� ���������� �������.
// ��������: Dst, Src, gr6, gr7.
macro STASG ( Dst, Src, Size )

extern _memcpy : label;

    // ����� ������ ��������� ��������� �������� ��������.
    // ������ ������������� ���� 2 + 2*Size
.if Size < 10;
    Src += Size;
    Dst += Size;
.repeat Size;
    gr7 = [ --Src ];
    [ --Dst ] = gr7;
.endrepeat;
.endif;

	// ���� �� ������ ��������� �������, �� ���������� memcpy
    // ������ ���� 20 ����. ����������� ������ Size = (20-2)/2 = 9.
.if Size >= 10;
    gr7 = Size;
    
    if false delayed skip 0;
    push ar5;
    push gr7;
    
    if false delayed skip 0;
    push Src;
    push Dst;
    
    call _memcpy;
    
    ar7 -= 2;
    
    if false delayed skip 0;
    pop gr7;
    pop ar5;
    
.endif;

end STASG;


//===== ������ UGFLD =======
// ������ �  ������������ �������� ���� ���������
// �� �����:    Addr    - ������� � ������� 32-������� �����
//              Offset  - �������� �� ������ ����� � �����
//              Size    - ������ ���� � �����
// �� ������:   Res     - ������� � �����������
// ���������: ������ � ��������� ����������� �� ������� ��� � �������.
macro UGFLD ( Res, Addr, Offset, Size )
    Res = [ Addr ];
    Res <<= 32 - Offset - Size;
    Res >>= 32 - Size;
end UGFLD;


//===== ������ IGFLD =======
// ������ �  ��������� �������� ���� ���������
// �� �����:    Addr    - ������� � ������� 32-������� �����
//              Offset  - �������� �� ������ ����� � �����
//              Size    - ������ ���� � �����
// �� ������:   Res     - ������� � �����������
// ���������: ������ � ��������� ����������� �� ������� ��� � �������.
macro IGFLD ( Res, Addr, Offset, Size )
    Res = [ Addr ];
    Res <<= 32 - Offset - Size;
    Res A>>= 32 - Size;
end IGFLD;


//===== ������ ESFLD =======
// ���������� ����� ��� �������� �������� ���� ���������.
// �� �����:    Input   - ������� � ��������� ����
//              Offset  - �������� �� ������ ����� � �����
//              Size    - ������ ���� � �����
// �� ������:   Res     - ������� � �����������
// ���������: ������ � ��������� ����������� �� ������� ��� � �������.
macro ESFLD ( Res, Offset, Size, Input )
    Res = Input << 32 - Size;
    Res A>>= 32 - Size;
end ESFLD;


//===== ������ SFLD0 =======
// ������������ �������� ���� ���������.
// �� �����:    Addr    - ������� � ������� 32-������� �����
//              Offset  - �������� �� ������ ����� � �����
//              Size    - ������ ���� � �����
//              Val     - ������������� ���� ��������
//                          (������� ����� gr0 ���� ���������)
// ���������: ������ � ��������� ����������� �� ������� ��� � �������.
macro SFLD0 ( Addr, Offset, Size, Val )
    push ar0, gr0;
    gr0 = [ Addr ];
    gr7 = ( 0ffffffffh << ( Offset + Size ) ) or
          ( 0ffffffffh >> ( 32 - Offset ) );   // �����
    gr0 = gr0 and gr7;  // �������� ����

        // some work to avoid shift on zero bits.
.if ( 32 - Size ) == 0;
    gr7 = Val;
.endif;
.if ( 32 - Size ) != 0;
    gr7 = Val << ( 32 - Size );
.endif;

    gr7 >>= ( 32 - Offset - Size );
    gr7 = gr0 or gr7;   // ������������� ����
    pop ar0, gr0;
    [ Addr ] = gr7;
end SFLD0;


//===== ������ SFLD1 =======
// ������������ �������� ���� ���������.
// �� �����:    Addr    - ������� � ������� 32-������� �����
//              Offset  - �������� �� ������ ����� � �����
//              Size    - ������ ���� � �����
//              Val     - ������������� ���� ��������
//                          (������� ����� gr1 ���� ���������).
// ���������: ������ � ��������� ����������� �� ������� ��� � �������.
macro SFLD1 ( Addr, Offset, Size, Val )
    push ar1, gr1;
    gr1 = [ Addr ];
    gr7 = ( 0ffffffffh << ( Offset + Size ) ) or
          ( 0ffffffffh >> ( 32 - Offset ) );   // �����
    gr1 = gr1 and gr7;  // �������� ����

        // some work to avoid shift on zero bits.
.if ( 32 - Size ) == 0;
    gr7 = Val;
.endif;
.if ( 32 - Size ) != 0;
    gr7 = Val << ( 32 - Size );
.endif;

    gr7 >>= ( 32 - Offset - Size );
    gr7 = gr1 or gr7;   // ������������� ����
    pop ar1, gr1;
    [ Addr ] = gr7;
end SFLD1;


//======= ������ FEQ =======
// Res = ( Arg1 == Arg2 )
// �� �����: Arg1, Arg2 - �������� �� ���������� ���� float,
//           ���� ������ ���� �������� �� ������� ������.
// �� ������: Res - ������� �� ��������� ���� bool
// ��������: ar5, gr7.
macro FEQ ( Res, Arg1, Arg2 )
extern FCmp :label;
own Cont :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = Arg1;
    [ ar5 ] = Arg2;
    call FCmp;
    if carry delayed skip Cont
        with Res = false noflags;
    sp -= 2;
    // cond. skip Cont
    if <>0 skip Cont;
    Res++;
<Cont>
end FEQ;


//======= ������ FNE =======
// Res = ( Arg1 != Arg2 )
// �� �����: Arg1, Arg2 - �������� �� ���������� ���� float,
//           ���� ������ ���� �������� �� ������� ������.
// �� ������: Res - ������� �� ��������� ���� bool
// ��������: ar5, gr7.
macro FNE ( Res, Arg1, Arg2 )
extern FCmp :label;
own True :label;
own Cont :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = Arg1;
    [ ar5 ] = Arg2;
    call FCmp;
    if carry delayed skip True
        with Res = false noflags;
    sp -= 2;
    // cond. skip Cont
    if =0 skip Cont;
<True>
    Res++;
<Cont>
end FNE;


//======= ������ FLT =======
// Res = ( Arg1 < Arg2 )
// �� �����: Arg1, Arg2 - �������� �� ���������� ���� float,
//           ���� ������ ���� �������� �� ������� ������.
// �� ������: Res - ������� �� ��������� ���� bool
// ��������: gr7, ar5.
macro FLT ( Res, Arg1, Arg2 )
extern FCmp :label;
own Cont :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = Arg1;
    [ ar5 ] = Arg2;
    call FCmp;
    if carry delayed skip Cont
        with Res = false noflags;
    sp -= 2;
    // cond. skip Cont
    if >= skip Cont;
    Res++;
<Cont>
end FLT;


//======= ������ FGT =======
// Res = ( Arg1 > Arg2 )
// �� �����: Arg1, Arg2 - �������� �� ���������� ���� float,
//           ���� ������ ���� �������� �� ������� ������.
// �� ������: Res - ������� �� ��������� ���� bool
// ��������: gr7, ar5
macro FGT ( Res, Arg1, Arg2 )
    FLT( Res, Arg2, Arg1 );
end FGT;


//======= ������ FGE =======
// Res = ( Arg1 >= Arg2 )
// �� �����: Arg1, Arg2 - �������� �� ���������� ���� float,
//           ���� ������ ���� �������� �� ������� ������.
// �� ������: Res - ������� �� ��������� ���� bool
// ��������: gr7, ar5
macro FGE ( Res, Arg1, Arg2 )
extern FCmp :label;
own Cont :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = Arg1;
    [ ar5 ] = Arg2;
    call FCmp;
    if carry delayed skip Cont
        with Res = false noflags;
    sp -= 2;
    // cond. skip Cont
    if < skip Cont;
    Res++;
<Cont>
end FGE;


//======= ������ FLE =======
// Res = ( Arg1 <= Arg2 )
// �� �����: Arg1, Arg2 - �������� �� ���������� ���� float,
//           ���� ������ ���� �������� �� ������� ������.
// �� ������: Res - ������� �� ��������� ���� bool
// ��������: gr7, ar5
macro FLE ( Res, Arg1, Arg2 )
    FGE( Res, Arg2, Arg1 );
end FLE;


//====== ������ FNEG =======
// Res = - Arg
// �� �����:    Arg - ������� �� ��������� ���� float.
// �� ������:   Res - ������� �� ��������� ���� bool.
macro FNEG ( Res, Arg )
    Res = 80000000h;
    Res = Res xor Arg;
end FNEG;


//====== ������ FADD =======
// �������� ����� ���� float
// Res = Arg1 + Arg2
// ��������: gr7, ar5
// ���� ������ ���� �������� �� ������� ������
macro FADD ( Res, Arg1, Arg2 )
extern FAdd :label;

    CALL_BUILTIN_2x1( FAdd, Arg1, Arg2, Res );

end FADD;


//====== ������ FSUB =======
// ��������� ����� ���� float
// Res = Arg1 - Arg2
// ��������: gr7, ar5
// ���� ������ ���� �������� �� ������� ������
// Arg2 �� ������ ���� gr7
macro FSUB ( Res, Arg1, Arg2 )
extern FAdd :label;

        // ������ ���� Arg2 � ����� ����������.
    FNEG( gr7, Arg2 );
    CALL_BUILTIN_2x1( FAdd, Arg1, gr7, Res );

end FSUB;


//====== ������ FMUL =======
// ��������� ����� ���� float
// Res = Arg1 * Arg2
// ��������: gr7, ar5
// ���� ������ ���� �������� �� ������� ������
macro FMUL ( Res, Arg1, Arg2 )
extern FMul :label;

    CALL_BUILTIN_2x1( FMul, Arg1, Arg2, Res );

end FMUL;


//====== ������ FDIV =======
// ������� ����� ���� float
// Res = Arg1 / Arg2
// ��������: gr7, ar5
// ���� ������ ���� �������� �� ������� ������
macro FDIV ( Res, Arg1, Arg2 )
extern FDiv :label;

    CALL_BUILTIN_2x1( FDiv, Arg1, Arg2, Res );

end FDIV;


//====== ������ I32TOF =======
// ������������ 32-��������� ����� ����� �� ������ � ����� ���� float.
// ���������: ���� �������� ����� �������������� �� float �������� �����
// �������� ����� ������� 1.
// �� �����:    Arg - ������� � ���������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �����������.
// ��������:    gr7, ar5
macro I32TOF ( Res, Arg )
extern ConvI32toF :label;

    call ConvI32toF
        with gr7 = Arg;
    with Res = gr7;
end I32TOF;


//====== ������ U32TOF =======
// ������������ 32-��������� ����� ����� ��� ����� � ����� ���� float.
// ���������: ���� �������� ����� �������������� �� float �������� �����
// ����������� ����� ������� 1.
// �� �����:    Arg - ������� � ���������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �����������.
// ��������:    gr7, ar5
macro U32TOF ( Res, Arg )
extern ConvU32toF :label;

    call ConvU32toF
        with gr7 = Arg;
    with Res = gr7;
end U32TOF;


//======= ������ I64TOF =======
// ������������ 64-��������� ����� ����� �� ������ � ����� ���� float.
// �� �����:    ArgLo - ������� � �������� 32 ������ ��������,
//              ArgHi - ������� �� �������� 32 ������ ��������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �����������.
// ��������:    gr7, ar5
macro I64TOF ( Res, ArgLo, ArgHi )
extern ConvI64toF :label;

    CALL_BUILTIN_2x1( ConvI64toF, ArgLo, ArgHi, Res );

end I64TOF;


//======= ������ U64TOF =======
// ������������ 64-��������� ����� ����� ��� ����� � ����� ���� float.
// �� �����:    ArgLo - ������� � �������� 32 ������ ��������,
//              ArgHi - ������� �� �������� 32 ������ ��������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �����������.
// ��������:    gr7, ar5
macro U64TOF ( Res, ArgLo, ArgHi )
extern ConvU64toF :label;

    CALL_BUILTIN_2x1( ConvU64toF, ArgLo, ArgHi, Res );

end U64TOF;


//====== ������ FTOI32 =======
// ������������ ����� ���� float � 32-��������� ����� �� ������,
// �.�. � ����� ������������� �������� ��� ������� 1.
// �� �����:    Arg - ������� � ���������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �����������.
// ��������:    gr7, ar5
macro FTOI32 ( Res, Arg )
extern ConvFtoI32 :label;

    call ConvFtoI32
        with gr7 = Arg;
    with Res = gr7;

end FTOI32;


//====== ������ FTOU32 =======
// ������������ ����� ���� float � 32-��������� ����� ��� �����,
// �.�. � ����� ������������� ����������� ��� ������� 1.
// �� �����:    Arg - ������� � ���������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �����������.
// ��������:    gr7, ar5
macro FTOU32 ( Res, Arg )
extern ConvFtoU32 :label;

    call ConvFtoU32
        with gr7 = Arg;
    with Res = gr7;

end FTOU32;


//====== ������ FTOI64 =======
// ������������ ����� ���� float � 64-��������� ����� �� ������.
// �� �����:    Arg - ������� � ���������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� � �������� 32 ������ ����������,
//              ResHi - ������� �� �������� 32 ������ ����������.
// ��������:    gr7, ar5
macro FTOI64 ( ResLo, ResHi, Arg )
extern ConvFtoI64 :label;

    CALL_BUILTIN_1x2( ConvFtoI64, Arg, ResHi, ResLo );

//    sp += 2;
//    call ConvFtoI64 with gr7 = Arg;
//    ar5 = sp;
//    ResHi = [ --ar5 ];
//    ResLo = [ --ar5 ];
//    sp -= 2;
end FTOI64;


//====== ������ FTOU64 =======
// ������������ ����� ���� float � 64-��������� ����� ��� �����.
// �� �����:    Arg - ������� � ���������,
//              ���� �������� �� ��������� ������.
// �� ������:   ResLo - ������� � �������� 32 ������ ����������,
//              ResHi - ������� �� �������� 32 ������ ����������.
// ��������:    gr7, ar5
macro FTOU64 ( ResLo, ResHi, Arg )
extern ConvFtoU64 :label;

    CALL_BUILTIN_1x2( ConvFtoU64, Arg, ResHi, ResLo );
//    sp += 2;
//    ar5 = sp;
//    [ --ar5 ] = Arg;
//    call ConvFtoU64;
//    ar5 = sp;
//    ResHi = [ --ar5 ];
//    ResLo = [ --ar5 ];
//    sp -= 2;
end FTOU64;


//======= ������ DEQ =======
// �������� ���� ����� ���� double �� ���������.
// �� �����:    LLo - ������� � �������� 32 ������ ������ ��������,
//              LHi - ������� �� �������� 32 ������ ������ ��������,
//              RLo - ������� � �������� 32 ������ ������� ��������,
//              RHi - ������� �� �������� 32 ������ ������� ��������,
//              ���� �������� �� ������� ������.
// �� ������: Res - ������� �� ��������� ���� bool
// ��������:    ar5, gr7
macro DEQ ( Res, LLo, LHi, RLo, RHi )
extern  DCmp :label;
own     Cont :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DCmp;
    if carry delayed skip Cont
        with Res = false noflags;
    sp -= 4;
    // cond. skip Cont
    if <>0 skip Cont;
    Res++;
<Cont>
end DEQ;


//======= ������ DNE =======
// �������� ���� ����� ���� double �� �����������.
// �� �����:    LLo - ������� � �������� 32 ������ ������ ��������,
//              LHi - ������� �� �������� 32 ������ ������ ��������,
//              RLo - ������� � �������� 32 ������ ������� ��������,
//              RHi - ������� �� �������� 32 ������ ������� ��������,
// �� ������: Res - ������� �� ��������� ���� bool
// ��������:    gr7
macro DNE ( Res, LLo, LHi, RLo, RHi )
extern  DCmp :label;
own     Cont :label;
own     True :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DCmp;
    if carry delayed skip True
        with Res = false noflags;
    sp -= 4;
    // cond. skip True
    if =0 skip Cont;
<True>
    Res++;
<Cont>
end DNE;


//======= ������ DLT =======
// �������� ���� ����� ���� double �� <.
// �� �����:    LLo - ������� � �������� 32 ������ ������ ��������,
//              LHi - ������� �� �������� 32 ������ ������ ��������,
//              RLo - ������� � �������� 32 ������ ������� ��������,
//              RHi - ������� �� �������� 32 ������ ������� ��������,
//              ���� �������� �� ������� ������.
// �� ������: Res - ������� �� ��������� ���� bool
// ��������:    gr7, ar5.
macro DLT ( Res, LLo, LHi, RLo, RHi )
extern  DCmp    :label;
own     Cont    :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DCmp;
    if carry delayed skip Cont
        with Res = false noflags;
    sp -= 4;
    // cond. skip Cont
    if >= skip Cont;
    Res++;
<Cont>
end DLT;


//======= ������ DGT =======
// �������� ���� ����� ���� double �� >.
// �� �����:    LLo - ������� � �������� 32 ������ ������ ��������,
//              LHi - ������� �� �������� 32 ������ ������ ��������,
//              RLo - ������� � �������� 32 ������ ������� ��������,
//              RHi - ������� �� �������� 32 ������ ������� ��������,
//              ���� �������� �� ������� ������.
// �� ������: Res - ������� �� ��������� ���� bool
// ��������:    gr7, ar5.
macro DGT ( Res, LLo, LHi, RLo, RHi )
    DLT( Res, RLo, RHi, LLo, LHi );
end DGT;


//======= ������ DGE =======
// �������� ���� ����� ���� double �� >=.
// �� �����:    LLo - ������� � �������� 32 ������ ������ ��������,
//              LHi - ������� �� �������� 32 ������ ������ ��������,
//              RLo - ������� � �������� 32 ������ ������� ��������,
//              RHi - ������� �� �������� 32 ������ ������� ��������,
//              ���� �������� �� ������� ������.
// �� ������: Res - ������� �� ��������� ���� bool
// ��������:    gr7, ar5.
macro DGE ( Res, LLo, LHi, RLo, RHi )
extern  DCmp    :label;
own     Cont    :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DCmp;
    if carry delayed skip Cont
        with Res = false noflags;
    sp -= 4;
    // cond. skip Cont
    if < skip Cont;
    Res++;
<Cont>
end DGE;


//======= ������ DLE =======
// �������� ���� ����� ���� double �� <=.
// �� �����:    LLo - ������� � �������� 32 ������ ������ ��������,
//              LHi - ������� �� �������� 32 ������ ������ ��������,
//              RLo - ������� � �������� 32 ������ ������� ��������,
//              RHi - ������� �� �������� 32 ������ ������� ��������,
//              ���� �������� �� ������� ������.
// �� ������: Res - ������� �� ��������� ���� bool
// ��������:    gr7, ar5.
macro DLE ( Res, LLo, LHi, RLo, RHi )
    DGE( Res, RLo, RHi, LLo, LHi );
end DLE;


//====== ������ DNEG =======
// ��������� ����� ����� ���� double.
// �� �����:    ArgLo - ������� 32 ���� ��������,
//              ArgHi - ������� 32 ���� ��������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
macro DNEG ( ResLo, ResHi, ArgLo, ArgHi )
    ResHi = 80000000h
        with ResLo = ArgLo noflags;
    ResHi = ResHi xor ArgHi noflags;
end DNEG;


//======= ������ DADD =======
// �������� ���� ����� ���� double.
// �� �����:    LLo - ������� � �������� 32 ������ ������ ��������,
//              LHi - ������� �� �������� 32 ������ ������ ��������,
//              RLo - ������� � �������� 32 ������ ������� ��������,
//              RHi - ������� �� �������� 32 ������ ������� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
// ��������:    gr7, ar5.
macro DADD ( ResLo, ResHi, LLo, LHi, RLo, RHi )
extern DAdd :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DAdd;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end DADD;


//======= ������ DSUB =======
// ��������� ���� ����� ���� double.
// �� �����:    LLo - ������� � �������� 32 ������ ������ ��������,
//              LHi - ������� �� �������� 32 ������ ������ ��������,
//              RLo - ������� � �������� 32 ������ ������� ��������,
//              RHi - ������� �� �������� 32 ������ ������� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
// ��������:    gr7, ar5.
macro DSUB ( ResLo, ResHi, LLo, LHi, RLo, RHi )
extern DAdd :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    gr7 = 80000000h;
    [ ar5++ ] = RLo
        with gr7 = RHi xor gr7;
    [ ar5 ] = gr7;
    call DAdd;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end DSUB;


//======= ������ DMUL =======
// ��������� ���� ����� ���� double.
// �� �����:    LLo - ������� � �������� 32 ������ ������ ��������,
//              LHi - ������� �� �������� 32 ������ ������ ��������,
//              RLo - ������� � �������� 32 ������ ������� ��������,
//              RHi - ������� �� �������� 32 ������ ������� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
// ��������:    gr7, ar5.
macro DMUL ( ResLo, ResHi, LLo, LHi, RLo, RHi )
extern DMul :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DMul;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end DMUL;


//======= ������ DDIV =======
// �������� ���� ����� ���� double.
// �� �����:    LLo - ������� � �������� 32 ������ ������ ��������,
//              LHi - ������� �� �������� 32 ������ ������ ��������,
//              RLo - ������� � �������� 32 ������ ������� ��������,
//              RHi - ������� �� �������� 32 ������ ������� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
// ��������:    gr7, ar5.
macro DDIV ( ResLo, ResHi, LLo, LHi, RLo, RHi )
extern DDiv :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DDiv;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end DDIV;


//======= ������ I32TOD =======
// ������������ 32-��������� ����� ����� �� ������ � ������������ �����
// ���� double.
// �� �����:    Arg - ������� � ���������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
// ��������:    gr7, ar5.
macro I32TOD ( ResLo, ResHi, Arg )
extern ConvI32toD :label;

    CALL_BUILTIN_1x2( ConvI32toD, Arg, ResHi, ResLo );

end I32TOD;


//======= ������ U32TOD =======
// ������������ 32-��������� ����� ����� ��� ����� � ������������ �����
// ���� double.
// �� �����:    Arg - ������� � ���������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
// ��������:    gr7, ar5.
macro U32TOD ( ResLo, ResHi, Arg )
extern ConvU32toD :label;

    CALL_BUILTIN_1x2( ConvU32toD, Arg, ResHi, ResLo );

end U32TOD;


//======= ������ I64TOD =======
// ������������ 64-��������� ����� ����� �� ������ � ������������ �����
// ���� double.
// �� �����:    ArgLo - ������� 32 ���� ��������,
//              ArgHi - ������� 32 ���� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
// ��������:    gr7, ar5.
macro I64TOD ( ResLo, ResHi, ArgLo, ArgHi )
extern ConvI64toD :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvI64toD;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end I64TOD;


//======= ������ U64TOD =======
// ������������ 64-��������� ����� ����� ��� ����� � ������������ �����
// ���� double.
// �� �����:    ArgLo - ������� 32 ���� ��������,
//              ArgHi - ������� 32 ���� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
// ��������:    gr7, ar5.
macro U64TOD ( ResLo, ResHi, ArgLo, ArgHi )
extern ConvU64toD :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvU64toD;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end U64TOD;


//======= ������ DTOI32 =======
// ������������ ������������ ����� ���� double
// � 32-��������� ����� ����� �� ������.
// �� �����:    ArgLo - ������� 32 ���� ��������,
//              ArgHi - ������� 32 ���� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �����������.
// ��������:    gr7, ar5
macro DTOI32 ( Res, ArgLo, ArgHi )
extern ConvDtoI32 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvDtoI32;
    sp -= 2
        with Res = gr7;
end DTOI32;


//======= ������ DTOU32 =======
// ������������ ������������ ����� ���� double
// � 32-��������� ����� ����� ��� �����.
// �� �����:    ArgLo - ������� 32 ���� ��������,
//              ArgHi - ������� 32 ���� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �����������.
// ��������:    gr7, ar5
macro DTOU32 ( Res, ArgLo, ArgHi )
extern ConvDtoU32 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvDtoU32;
    sp -= 2
        with Res = gr7;
end DTOU32;


//======= ������ DTOI64 =======
// ������������ ������������ ����� ���� double
// � 64-��������� ����� ����� �� ������.
// �� �����:    ArgLo - ������� 32 ���� ��������,
//              ArgHi - ������� 32 ���� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
macro DTOI64 ( ResLo, ResHi, ArgLo, ArgHi )
extern ConvDtoI64 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvDtoI64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end DTOI64;


//======= ������ DTOU64 =======
// ������������ ������������ ����� ���� double
// � 64-��������� ����� ����� ��� �����.
// �� �����:    ArgLo - ������� 32 ���� ��������,
//              ArgHi - ������� 32 ���� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
macro DTOU64 ( ResLo, ResHi, ArgLo, ArgHi )
extern ConvDtoU64 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvDtoU64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end DTOU64;


//======= ������ FTOD =======
// ������������ ����� ���� float � ����� ���� double.
// �� �����:    Arg - ������� � ���������,
//              ���� �������� �� ������� ������.
// �� ������:   ResLo - ������� 32 ���� ����������,
//              ResHi - ������� 32 ���� ����������.
// ��������:    gr7, ar5.
macro FTOD ( ResLo, ResHi, Arg )
extern ConvFtoD :label;

    ar5 = sp;
    sp += 2;
    [ ar5 += 1 ] = Arg;
    call ConvFtoD;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end FTOD;


//======== ������ DTOF =======
// ������������ ����� ���� double � ����� ���� float.
// �� �����:    ArgLo - ������� 32 ���� ��������,
//              ArgHi - ������� 32 ���� ��������,
//              ���� �������� �� ������� ������.
// �� ������:   Res - ������� � �����������.
// ��������:    gr7, ar5
macro DTOF ( Res, ArgLo, ArgHi )
extern ConvDtoF :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvDtoF;
    sp -= 2
        with Res = gr7;
end DTOF;


macro FPIEEE_FLAGS_DEF ()

    const _FPIEEE_Invalid   =  1;
    const _FPIEEE_DivByZero =  2;
    const _FPIEEE_Overflow  =  4;
    const _FPIEEE_Underflow =  8;
    const _FPIEEE_Inexact   = 16;

end FPIEEE_FLAGS_DEF;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                      ����� ����� rtmacro.asm                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////
